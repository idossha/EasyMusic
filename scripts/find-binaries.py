#!/usr/bin/env python3
"""
Script to find all Python binaries that need code signing for Apple Silicon macOS builds.
Generates a list of binaries in spotdl_env and binaries directories that should be signed.
"""

import os
import sys
from pathlib import Path
from typing import List

def find_binaries_to_sign() -> List[str]:
    """Find all binaries that need to be signed."""
    binaries = []

    # Directories to search
    search_dirs = ["spotdl_env", "binaries"]

    # File extensions that are executable binaries (not source files)
    binary_extensions = {
        # Python extensions
        '.so', '.dylib', '.pyd',
        # Executable files (no extension or executable bit)
    }

    # Patterns to exclude (matching electron-builder mac.signIgnore)
    exclude_patterns = [
        "**/*.py",
        "**/*.pyc",
        "**/*.pyo",
        "**/*.mo",
        "**/__pycache__/**",
        "**/site-packages/**"
    ]

    def should_exclude(path: str) -> bool:
        """Check if a path should be excluded from signing."""
        path_str = str(path)

        # Check exclude patterns
        for pattern in exclude_patterns:
            if pattern.startswith("**/") and pattern.endswith("/**"):
                # Directory pattern like **/__pycache__/**
                dir_name = pattern[3:-3]
                if dir_name in path_str:
                    return True
            elif pattern.startswith("**/"):
                # File pattern like **/*.py
                if path_str.endswith(pattern[2:]):
                    return True

        return False

    for search_dir in search_dirs:
        dir_path = Path(search_dir)
        if not dir_path.exists():
            print(f"Warning: Directory {search_dir} does not exist, skipping")
            continue

        print(f"Searching in {search_dir}...")

        for root, dirs, files in os.walk(dir_path):
            for file in files:
                file_path = Path(root) / file

                # Skip if should be excluded
                if should_exclude(file_path):
                    continue

                # Check if it's a binary file
                is_binary = False

                # Check file extension
                if file_path.suffix.lower() in binary_extensions:
                    is_binary = True

                # Check if file has executable bit (Unix-style)
                elif os.name != 'nt' and os.access(file_path, os.X_OK):
                    # Additional check: if it's in bin directory or has no extension
                    # but is executable, it might be a binary
                    if not file_path.suffix or 'bin' in str(file_path.parent):
                        # Do a basic check to see if it looks like a binary
                        try:
                            with open(file_path, 'rb') as f:
                                header = f.read(4)
                                # Check for ELF, Mach-O, or other binary signatures
                                if (header.startswith(b'\x7fELF') or  # ELF
                                    header.startswith(b'\xfe\xed\xfa\xce') or  # Mach-O 32-bit
                                    header.startswith(b'\xfe\xed\xfa\xcf') or  # Mach-O 64-bit
                                    header.startswith(b'\xcf\xfa\xed\xfe') or  # Mach-O reverse
                                    header.startswith(b'\xce\xfa\xed\xfe')):   # Mach-O reverse 32-bit
                                    is_binary = True
                        except:
                            pass

                if is_binary:
                    binaries.append(str(file_path))
                    print(f"  Found: {file_path}")

    return sorted(binaries)

def main():
    """Main function."""
    print("üîç Finding binaries that need code signing...")

    try:
        binaries = find_binaries_to_sign()

        if not binaries:
            print("‚ùå No binaries found to sign")
            return 1

        print(f"\n‚úÖ Found {len(binaries)} binaries to sign")

        # Write to file
        output_file = "binaries_to_sign.txt"
        with open(output_file, 'w') as f:
            f.write("# Auto-generated list of binaries to sign\n")
            f.write("# Generated by scripts/find-binaries.py\n")
            f.write("\n")
            for binary in binaries:
                f.write(f"{binary}\n")

        print(f"üìù Wrote {len(binaries)} binaries to {output_file}")

        # Display first few for verification
        print("\nFirst few binaries:")
        for binary in binaries[:5]:
            print(f"  {binary}")
        if len(binaries) > 5:
            print(f"  ... and {len(binaries) - 5} more")

        return 0

    except Exception as e:
        print(f"‚ùå Error: {e}")
        return 1

if __name__ == "__main__":
    sys.exit(main())